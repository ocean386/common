// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ocean386/common/orm/model"
)

func newSpotGrid(db *gorm.DB, opts ...gen.DOOption) spotGrid {
	_spotGrid := spotGrid{}

	_spotGrid.spotGridDo.UseDB(db, opts...)
	_spotGrid.spotGridDo.UseModel(&model.SpotGrid{})

	tableName := _spotGrid.spotGridDo.TableName()
	_spotGrid.ALL = field.NewAsterisk(tableName)
	_spotGrid.ID = field.NewInt64(tableName, "id")
	_spotGrid.GridID = field.NewString(tableName, "grid_id")
	_spotGrid.UserID = field.NewInt64(tableName, "user_id")
	_spotGrid.CurrencyID = field.NewString(tableName, "currency_id")
	_spotGrid.Simulation = field.NewInt64(tableName, "simulation")
	_spotGrid.TriggerBuySellType = field.NewInt64(tableName, "trigger_buy_sell_type")
	_spotGrid.GridStatus = field.NewInt64(tableName, "grid_status")
	_spotGrid.TransactionType = field.NewInt64(tableName, "transaction_type")
	_spotGrid.ImmediateTrigger = field.NewInt64(tableName, "immediate_trigger")
	_spotGrid.TriggerGridPrice = field.NewFloat64(tableName, "trigger_grid_price")
	_spotGrid.SpecialPrice = field.NewFloat64(tableName, "special_price")
	_spotGrid.MinPrice = field.NewFloat64(tableName, "min_price")
	_spotGrid.MaxPrice = field.NewFloat64(tableName, "max_price")
	_spotGrid.MinStopPrice = field.NewFloat64(tableName, "min_stop_price")
	_spotGrid.MaxStopPrice = field.NewFloat64(tableName, "max_stop_price")
	_spotGrid.GridEqualPriceFirst = field.NewFloat64(tableName, "grid_equal_price_first")
	_spotGrid.GridEqualPriceSecond = field.NewFloat64(tableName, "grid_equal_price_second")
	_spotGrid.GridNumber = field.NewInt64(tableName, "grid_number")
	_spotGrid.GridCurrencyNumber = field.NewFloat64(tableName, "grid_currency_number")
	_spotGrid.CurrencyPosition = field.NewFloat64(tableName, "currency_position")
	_spotGrid.ProfitAmount = field.NewFloat64(tableName, "profit_amount")
	_spotGrid.ProfitPercent = field.NewFloat64(tableName, "profit_percent")
	_spotGrid.FilledTimes = field.NewFloat64(tableName, "filled_times")
	_spotGrid.GridProfitAmount = field.NewFloat64(tableName, "grid_profit_amount")
	_spotGrid.InitAmount = field.NewFloat64(tableName, "init_amount")
	_spotGrid.Fee = field.NewFloat64(tableName, "fee")
	_spotGrid.CreatedAt = field.NewInt64(tableName, "created_at")
	_spotGrid.UpdatedAt = field.NewInt64(tableName, "updated_at")

	_spotGrid.fillFieldMap()

	return _spotGrid
}

// spotGrid 网格列表-现货
type spotGrid struct {
	spotGridDo

	ALL                  field.Asterisk
	ID                   field.Int64   // 主键ID
	GridID               field.String  // 网格ID
	UserID               field.Int64   // 用户ID
	CurrencyID           field.String  // 币种ID
	Simulation           field.Int64   // 模拟订单: 0-全部,1-否, 2-是
	TriggerBuySellType   field.Int64   // 触发买卖: 0-全部,1-买入,2-卖出 3-不建仓
	GridStatus           field.Int64   // 网格状态:0-全部,1-等待触发,2-已暂停,3-正在运行,4-停止&不平仓,5-停止&平仓,6-已撤销
	TransactionType      field.Int64   // 交易模式: 0-全部,1-正常买卖,2-特价买卖(卖高特价,买低特价)
	ImmediateTrigger     field.Int64   // 立即触发: 0-全部,1-否, 2-是
	TriggerGridPrice     field.Float64 // 触发价格
	SpecialPrice         field.Float64 // 特殊价格
	MinPrice             field.Float64 // 最低价格
	MaxPrice             field.Float64 // 最高价格
	MinStopPrice         field.Float64 // 最低停止价格
	MaxStopPrice         field.Float64 // 最高停止价格
	GridEqualPriceFirst  field.Float64 // 网格差价-主
	GridEqualPriceSecond field.Float64 // 网格差价-次
	GridNumber           field.Int64   // 网格数量
	GridCurrencyNumber   field.Float64 // 币种数量
	CurrencyPosition     field.Float64 // 持仓数量
	ProfitAmount         field.Float64 // 盈亏金额
	ProfitPercent        field.Float64 // 盈亏比例
	FilledTimes          field.Float64 // 成交次数
	GridProfitAmount     field.Float64 // 网格收益
	InitAmount           field.Float64 // 初始金额-USDT
	Fee                  field.Float64 // 手续费
	CreatedAt            field.Int64   // 创建时间
	UpdatedAt            field.Int64   // 更新时间

	fieldMap map[string]field.Expr
}

func (s spotGrid) Table(newTableName string) *spotGrid {
	s.spotGridDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s spotGrid) As(alias string) *spotGrid {
	s.spotGridDo.DO = *(s.spotGridDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *spotGrid) updateTableName(table string) *spotGrid {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.GridID = field.NewString(table, "grid_id")
	s.UserID = field.NewInt64(table, "user_id")
	s.CurrencyID = field.NewString(table, "currency_id")
	s.Simulation = field.NewInt64(table, "simulation")
	s.TriggerBuySellType = field.NewInt64(table, "trigger_buy_sell_type")
	s.GridStatus = field.NewInt64(table, "grid_status")
	s.TransactionType = field.NewInt64(table, "transaction_type")
	s.ImmediateTrigger = field.NewInt64(table, "immediate_trigger")
	s.TriggerGridPrice = field.NewFloat64(table, "trigger_grid_price")
	s.SpecialPrice = field.NewFloat64(table, "special_price")
	s.MinPrice = field.NewFloat64(table, "min_price")
	s.MaxPrice = field.NewFloat64(table, "max_price")
	s.MinStopPrice = field.NewFloat64(table, "min_stop_price")
	s.MaxStopPrice = field.NewFloat64(table, "max_stop_price")
	s.GridEqualPriceFirst = field.NewFloat64(table, "grid_equal_price_first")
	s.GridEqualPriceSecond = field.NewFloat64(table, "grid_equal_price_second")
	s.GridNumber = field.NewInt64(table, "grid_number")
	s.GridCurrencyNumber = field.NewFloat64(table, "grid_currency_number")
	s.CurrencyPosition = field.NewFloat64(table, "currency_position")
	s.ProfitAmount = field.NewFloat64(table, "profit_amount")
	s.ProfitPercent = field.NewFloat64(table, "profit_percent")
	s.FilledTimes = field.NewFloat64(table, "filled_times")
	s.GridProfitAmount = field.NewFloat64(table, "grid_profit_amount")
	s.InitAmount = field.NewFloat64(table, "init_amount")
	s.Fee = field.NewFloat64(table, "fee")
	s.CreatedAt = field.NewInt64(table, "created_at")
	s.UpdatedAt = field.NewInt64(table, "updated_at")

	s.fillFieldMap()

	return s
}

func (s *spotGrid) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *spotGrid) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 28)
	s.fieldMap["id"] = s.ID
	s.fieldMap["grid_id"] = s.GridID
	s.fieldMap["user_id"] = s.UserID
	s.fieldMap["currency_id"] = s.CurrencyID
	s.fieldMap["simulation"] = s.Simulation
	s.fieldMap["trigger_buy_sell_type"] = s.TriggerBuySellType
	s.fieldMap["grid_status"] = s.GridStatus
	s.fieldMap["transaction_type"] = s.TransactionType
	s.fieldMap["immediate_trigger"] = s.ImmediateTrigger
	s.fieldMap["trigger_grid_price"] = s.TriggerGridPrice
	s.fieldMap["special_price"] = s.SpecialPrice
	s.fieldMap["min_price"] = s.MinPrice
	s.fieldMap["max_price"] = s.MaxPrice
	s.fieldMap["min_stop_price"] = s.MinStopPrice
	s.fieldMap["max_stop_price"] = s.MaxStopPrice
	s.fieldMap["grid_equal_price_first"] = s.GridEqualPriceFirst
	s.fieldMap["grid_equal_price_second"] = s.GridEqualPriceSecond
	s.fieldMap["grid_number"] = s.GridNumber
	s.fieldMap["grid_currency_number"] = s.GridCurrencyNumber
	s.fieldMap["currency_position"] = s.CurrencyPosition
	s.fieldMap["profit_amount"] = s.ProfitAmount
	s.fieldMap["profit_percent"] = s.ProfitPercent
	s.fieldMap["filled_times"] = s.FilledTimes
	s.fieldMap["grid_profit_amount"] = s.GridProfitAmount
	s.fieldMap["init_amount"] = s.InitAmount
	s.fieldMap["fee"] = s.Fee
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
}

func (s spotGrid) clone(db *gorm.DB) spotGrid {
	s.spotGridDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s spotGrid) replaceDB(db *gorm.DB) spotGrid {
	s.spotGridDo.ReplaceDB(db)
	return s
}

type spotGridDo struct{ gen.DO }

type ISpotGridDo interface {
	gen.SubQuery
	Debug() ISpotGridDo
	WithContext(ctx context.Context) ISpotGridDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISpotGridDo
	WriteDB() ISpotGridDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISpotGridDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISpotGridDo
	Not(conds ...gen.Condition) ISpotGridDo
	Or(conds ...gen.Condition) ISpotGridDo
	Select(conds ...field.Expr) ISpotGridDo
	Where(conds ...gen.Condition) ISpotGridDo
	Order(conds ...field.Expr) ISpotGridDo
	Distinct(cols ...field.Expr) ISpotGridDo
	Omit(cols ...field.Expr) ISpotGridDo
	Join(table schema.Tabler, on ...field.Expr) ISpotGridDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISpotGridDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISpotGridDo
	Group(cols ...field.Expr) ISpotGridDo
	Having(conds ...gen.Condition) ISpotGridDo
	Limit(limit int) ISpotGridDo
	Offset(offset int) ISpotGridDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISpotGridDo
	Unscoped() ISpotGridDo
	Create(values ...*model.SpotGrid) error
	CreateInBatches(values []*model.SpotGrid, batchSize int) error
	Save(values ...*model.SpotGrid) error
	First() (*model.SpotGrid, error)
	Take() (*model.SpotGrid, error)
	Last() (*model.SpotGrid, error)
	Find() ([]*model.SpotGrid, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SpotGrid, err error)
	FindInBatches(result *[]*model.SpotGrid, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SpotGrid) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISpotGridDo
	Assign(attrs ...field.AssignExpr) ISpotGridDo
	Joins(fields ...field.RelationField) ISpotGridDo
	Preload(fields ...field.RelationField) ISpotGridDo
	FirstOrInit() (*model.SpotGrid, error)
	FirstOrCreate() (*model.SpotGrid, error)
	FindByPage(offset int, limit int) (result []*model.SpotGrid, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISpotGridDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s spotGridDo) Debug() ISpotGridDo {
	return s.withDO(s.DO.Debug())
}

func (s spotGridDo) WithContext(ctx context.Context) ISpotGridDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s spotGridDo) ReadDB() ISpotGridDo {
	return s.Clauses(dbresolver.Read)
}

func (s spotGridDo) WriteDB() ISpotGridDo {
	return s.Clauses(dbresolver.Write)
}

func (s spotGridDo) Session(config *gorm.Session) ISpotGridDo {
	return s.withDO(s.DO.Session(config))
}

func (s spotGridDo) Clauses(conds ...clause.Expression) ISpotGridDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s spotGridDo) Returning(value interface{}, columns ...string) ISpotGridDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s spotGridDo) Not(conds ...gen.Condition) ISpotGridDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s spotGridDo) Or(conds ...gen.Condition) ISpotGridDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s spotGridDo) Select(conds ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s spotGridDo) Where(conds ...gen.Condition) ISpotGridDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s spotGridDo) Order(conds ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s spotGridDo) Distinct(cols ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s spotGridDo) Omit(cols ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s spotGridDo) Join(table schema.Tabler, on ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s spotGridDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s spotGridDo) RightJoin(table schema.Tabler, on ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s spotGridDo) Group(cols ...field.Expr) ISpotGridDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s spotGridDo) Having(conds ...gen.Condition) ISpotGridDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s spotGridDo) Limit(limit int) ISpotGridDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s spotGridDo) Offset(offset int) ISpotGridDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s spotGridDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISpotGridDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s spotGridDo) Unscoped() ISpotGridDo {
	return s.withDO(s.DO.Unscoped())
}

func (s spotGridDo) Create(values ...*model.SpotGrid) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s spotGridDo) CreateInBatches(values []*model.SpotGrid, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s spotGridDo) Save(values ...*model.SpotGrid) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s spotGridDo) First() (*model.SpotGrid, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpotGrid), nil
	}
}

func (s spotGridDo) Take() (*model.SpotGrid, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpotGrid), nil
	}
}

func (s spotGridDo) Last() (*model.SpotGrid, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpotGrid), nil
	}
}

func (s spotGridDo) Find() ([]*model.SpotGrid, error) {
	result, err := s.DO.Find()
	return result.([]*model.SpotGrid), err
}

func (s spotGridDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SpotGrid, err error) {
	buf := make([]*model.SpotGrid, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s spotGridDo) FindInBatches(result *[]*model.SpotGrid, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s spotGridDo) Attrs(attrs ...field.AssignExpr) ISpotGridDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s spotGridDo) Assign(attrs ...field.AssignExpr) ISpotGridDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s spotGridDo) Joins(fields ...field.RelationField) ISpotGridDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s spotGridDo) Preload(fields ...field.RelationField) ISpotGridDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s spotGridDo) FirstOrInit() (*model.SpotGrid, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpotGrid), nil
	}
}

func (s spotGridDo) FirstOrCreate() (*model.SpotGrid, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpotGrid), nil
	}
}

func (s spotGridDo) FindByPage(offset int, limit int) (result []*model.SpotGrid, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s spotGridDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s spotGridDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s spotGridDo) Delete(models ...*model.SpotGrid) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *spotGridDo) withDO(do gen.Dao) *spotGridDo {
	s.DO = *do.(*gen.DO)
	return s
}
